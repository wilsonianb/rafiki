type Query {
  account(id: String!): Account
  outgoingPayment(id: String!): OutgoingPayment
}

type Mutation {
  createOutgoingPayment(
    input: CreateOutgoingPaymentInput!
  ): OutgoingPaymentResponse!
  "Approve a Ready payment's quote."
  approveOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!
  "Requote a Cancelled payment."
  requoteOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!
  "Cancel a Ready payment."
  cancelOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!
}

type PageInfo {
  "Paginating forwards: the cursor to continue."
  endCursor: String
  "Paginating forwards: Are there more pages?"
  hasNextPage: Boolean!
  "Paginating backwards: Are there more pages?"
  hasPreviousPage: Boolean!
  "Paginating backwards: the cursor to continue."
  startCursor: String
}

type Amount {
  amount: Int!
  currency: String!
  scale: Int!
}

type Account {
  id: ID!
  balance: Amount!
  invoices(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): InvoiceConnection
}

type InvoiceConnection {
  pageInfo: PageInfo!
  edges: [InvoiceEdge!]!
}

type InvoiceEdge {
  node: Invoice!
  cursor: String!
}

type Invoice {
  id: ID!
  receivedAmount: Amount!
  maximumAmount: Amount
  active: Boolean!
  createdAt: String!
  expiresAt: String
  description: String
  totalAmount: String!
}

type OutgoingPayment {
  id: ID!
  state: PaymentState!
  error: String
  attempts: Int!
  intent: PaymentIntent
  quote: PaymentQuote
  sourceAccount: PaymentSourceAccount!
  destinationAccount: PaymentDestinationAccount!
  outcome: PaymentProgress!
}

type PaymentIntent {
  paymentPointer: String
  amountToSend: String #UInt64
  invoiceUrl: String
  autoApprove: Boolean!
}

enum PaymentState {
  "Will transition to READY when quote is complete"
  INACTIVE
  "Quote ready; awaiting user approval (ACTIVATED) or refusal (CANCELLING)"
  READY
  "Will transition to SENDING once payment funds are reserved"
  ACTIVATED
  "Paying, will transition to COMPLETED on success"
  SENDING
  "Will transition to CANCELLED when reserved funds are rolled back"
  CANCELLING
  "Payment aborted; can be requoted to INACTIVE"
  CANCELLED
  "Successfuly completion"
  COMPLETED
}

enum PaymentType {
  FIXED_SEND
  FIXED_DELIVERY
}

type PaymentQuote {
  timestamp: String!
  activationDeadline: String!
  targetType: PaymentType!
  minDeliveryAmount: String! #UInt64!
  maxSourceAmount: String! #UInt64!
  maxPacketAmount: String! #UInt64!
  minExchangeRate: Float!
  lowExchangeRateEstimate: Float!
  highExchangeRateEstimate: Float!
}

type PaymentSourceAccount {
  scale: Int!
  code: String!
}

type PaymentDestinationAccount {
  scale: Int!
  code: String!
  url: String
  paymentPointer: String
}

type PaymentProgress {
  # TODO should these amounts use the Amount type?
  amountSent: String! #UInt64!
  amountDelivered: String! #UInt64!
}

input CreateOutgoingPaymentInput {
  superAccountId: String!
  paymentPointer: String
  amountToSend: String #UInt64
  invoiceUrl: String
  autoApprove: Boolean!
}

type OutgoingPaymentResponse {
  code: String!
  success: Boolean!
  message: String
  payment: OutgoingPayment
}

#scalar UInt64
