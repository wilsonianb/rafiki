type Query {
  account(id: String!): Account

  "Fetch a page of accounts."
  accounts(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): AccountsConnection!

  outgoingPayment(id: String!): OutgoingPayment

  paymentPointer(id: String!): PaymentPointer

  "Get a webhook by ID."
  webhook("The ID of the webhook to get." id: String!): Webhook!
}

type Mutation {
  "Create account"
  createAccount(input: CreateAccountInput!): CreateAccountMutationResponse!

  "Update account"
  updateAccount(input: UpdateAccountInput!): UpdateAccountMutationResponse!

  "Delete account"
  deleteAccount(id: String!): DeleteAccountMutationResponse!

  createOutgoingPayment(
    input: CreateOutgoingPaymentInput!
  ): OutgoingPaymentResponse!
  "Approve a Ready payment's quote."
  approveOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!
  "Requote a Cancelled payment."
  requoteOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!
  "Cancel a Ready payment."
  cancelOutgoingPayment(paymentId: String!): OutgoingPaymentResponse!

  createPaymentPointer(
    input: CreatePaymentPointerInput
  ): CreatePaymentPointerMutationResponse!

  "Transfer between accounts"
  transfer(
    sourceAmount: UInt64!
    sourceAccountId: ID!
    destinationAccountId: ID!
    destinationAmount: UInt64
    autoCommit: Boolean
    idempotencyKey: ID!
  ): TransferMutationResponse

  "Create webhook"
  createWebhook(
    "The id of the account to create the webhook for."
    ilpAccountId: String!
  ): CreateWebhookMutationResponse

  "Update webhook"
  updateWebhook(
    "The id of the webhook to update."
    webhookId: ID!
  ): UpdateWebhookMutationResponse

  "Delete webhook"
  deleteWebhook(
    "The id of the webhook to delete."
    webhookId: ID!
  ): DeleteWebhookMutationResponse

  "Add account liquidity"
  addAccountLiquidity(
    input: AddAccountLiquidityInput!
  ): AddAccountLiquidityMutationResponse

  "Add asset liquidity"
  addAssetLiquidity(
    input: AddAssetLiquidityInput!
  ): AddAssetLiquidityMutationResponse

  "Create liquidity withdrawal from account"
  createAccountLiquidityWithdrawal(
    input: CreateAccountLiquidityWithdrawalInput!
  ): CreateAccountLiquidityWithdrawalMutationResponse

  "Create liquidity withdrawal from asset"
  createAssetLiquidityWithdrawal(
    input: CreateAssetLiquidityWithdrawalInput!
  ): CreateAssetLiquidityWithdrawalMutationResponse

  "Finalize liquidity withdrawal"
  finalizeLiquidityWithdrawal(
    "The id of the liquidity withdrawal to finalize."
    withdrawalId: String!
  ): FinalizeLiquidityWithdrawalMutationResponse

  "Rollback liquidity withdrawal"
  rollbackLiquidityWithdrawal(
    "The id of the liquidity withdrawal to rollback."
    withdrawalId: String!
  ): RollbackLiquidityWithdrawalMutationResponse
}

type PageInfo {
  "Paginating forwards: the cursor to continue."
  endCursor: String
  "Paginating forwards: Are there more pages?"
  hasNextPage: Boolean!
  "Paginating backwards: Are there more pages?"
  hasPreviousPage: Boolean!
  "Paginating backwards: the cursor to continue."
  startCursor: String
}

type AccountsConnection {
  pageInfo: PageInfo!
  edges: [AccountEdge!]!
}

type AccountEdge {
  node: Account!
  cursor: String!
}

input CreateAccountInput {
  id: String
  disabled: Boolean
  maxPacketAmount: UInt64
  http: HttpInput
  asset: AssetInput!
  stream: StreamInput
  routing: RoutingInput
}

input UpdateAccountInput {
  id: String!
  disabled: Boolean
  maxPacketAmount: UInt64
  http: HttpInput
  stream: StreamInput
  routing: RoutingInput
}

input HttpInput {
  incoming: HttpIncomingInput!
  outgoing: HttpOutgoingInput!
}

input HttpIncomingInput {
  authTokens: [String!]!
}

input HttpOutgoingInput {
  authToken: String!
  endpoint: String!
}

input AssetInput {
  code: String!
  scale: Int!
}

input StreamInput {
  enabled: Boolean!
}

input RoutingInput {
  staticIlpAddress: String!
}

input AddAccountLiquidityInput {
  "The id of the account to add liquidity."
  accountId: String!
  "Amount of liquidity to add."
  amount: UInt64!
  "The id of the transfer."
  id: String
}

input AddAssetLiquidityInput {
  "The id of the asset to add liquidity."
  assetId: String!
  "Amount of liquidity to add."
  amount: UInt64!
  "The id of the transfer."
  id: String
}

input CreateAccountLiquidityWithdrawalInput {
  "The id of the account to create the withdrawal for."
  accountId: String!
  "Amount of withdrawal."
  amount: UInt64!
  "The id of the withdrawal."
  id: String!
}

input CreateAssetLiquidityWithdrawalInput {
  "The id of the asset to create the withdrawal for."
  assetId: String!
  "Amount of withdrawal."
  amount: UInt64!
  "The id of the withdrawal."
  id: String!
}

type Asset {
  code: String!
  scale: Int!
}

enum LiquidityError {
  AlreadyFinalized
  AlreadyRolledBack
  InsufficientBalance
  InvalidId
  TransferExists
  UnknownAccount
  UnknownAsset
  UnknownWithdrawal
}

type Account {
  id: ID!
  disabled: Boolean!
  maxPacketAmount: UInt64
  http: Http
  asset: Asset!
  stream: Stream!
  routing: Routing

  balance: UInt64
  outgoingPayments(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): OutgoingPaymentConnection
  webhooks(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): WebhooksConnection
}

type Http {
  outgoing: HttpOutgoing!
}

type HttpOutgoing {
  authToken: String!
  endpoint: String!
}

type Stream {
  enabled: Boolean!
}

type Routing {
  staticIlpAddress: String!
  inheritFromRemote: Boolean
  dynamicIlpAddress: String
}

type PaymentPointer {
  id: ID!
  asset: Asset!
  invoices(
    "Paginating forwards: the cursor before the the requested page."
    after: String
    "Paginating backwards: the cursor after the the requested page."
    before: String
    "Paginating forwards: The first **n** elements from the page."
    first: Int
    "Paginating backwards: The last **n** elements from the page."
    last: Int
  ): InvoiceConnection
}

type InvoiceConnection {
  pageInfo: PageInfo!
  edges: [InvoiceEdge!]!
}

type InvoiceEdge {
  node: Invoice!
  cursor: String!
}

type Invoice {
  id: ID!
  maximumAmount: UInt64
  active: Boolean!
  createdAt: String!
  expiresAt: String
  description: String
}

type OutgoingPaymentConnection {
  pageInfo: PageInfo!
  edges: [OutgoingPaymentEdge!]!
}

type OutgoingPaymentEdge {
  node: OutgoingPayment!
  cursor: String!
}

type OutgoingPayment {
  id: ID!
  state: PaymentState!
  error: String
  stateAttempts: Int!
  intent: PaymentIntent
  quote: PaymentQuote
  sourceAccountId: ID!
  destinationAccount: PaymentDestinationAccount!
  outcome: OutgoingPaymentOutcome
  createdAt: String!
}

type PaymentIntent {
  paymentPointer: String
  amountToSend: UInt64
  invoiceUrl: String
  autoApprove: Boolean!
}

enum PaymentState {
  "Will transition to READY when quote is complete"
  INACTIVE
  "Quote ready; awaiting user approval (FUNDING) or refusal (CANCELLED)"
  READY
  "Will transition to SENDING once payment funds are reserved"
  FUNDING
  "Paying, will transition to COMPLETED on success"
  SENDING
  "Payment aborted; can be requoted to INACTIVE"
  CANCELLED
  "Successfuly completion"
  COMPLETED
}

enum PaymentType {
  FIXED_SEND
  FIXED_DELIVERY
}

type PaymentQuote {
  timestamp: String!
  activationDeadline: String!
  targetType: PaymentType!
  minDeliveryAmount: UInt64!
  maxSourceAmount: UInt64!
  maxPacketAmount: UInt64!
  minExchangeRate: Float!
  lowExchangeRateEstimate: Float!
  highExchangeRateEstimate: Float!
}

type PaymentDestinationAccount {
  scale: Int!
  code: String!
  url: String
}

type OutgoingPaymentOutcome {
  amountSent: UInt64!
}

input CreateOutgoingPaymentInput {
  sourceAccountId: String!
  assetId: String!
  paymentPointer: String
  amountToSend: UInt64
  invoiceUrl: String
  autoApprove: Boolean!
}

type OutgoingPaymentResponse {
  code: String!
  success: Boolean!
  message: String
  payment: OutgoingPayment
}

input CreatePaymentPointerInput {
  asset: AssetInput!
}

type WebhooksConnection {
  pageInfo: PageInfo!
  edges: [WebhookEdge!]!
}

type WebhookEdge {
  node: Webhook!
  cursor: String!
}

type Webhook {
  id: ID!
}

type CreateAccountMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  account: Account
}

type UpdateAccountMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  account: Account
}

type DeleteAccountMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

type CreatePaymentPointerMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  paymentPointer: PaymentPointer!
}

type TransferMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

type CreateWebhookMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  webhook: Webhook!
}

type UpdateWebhookMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  webhook: Webhook!
}

type DeleteWebhookMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

type AddAccountLiquidityMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

type AddAssetLiquidityMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

type CreateAccountLiquidityWithdrawalMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

type CreateAssetLiquidityWithdrawalMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

type FinalizeLiquidityWithdrawalMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

type RollbackLiquidityWithdrawalMutationResponse implements MutationResponse {
  code: String!
  success: Boolean!
  message: String!
  error: LiquidityError
}

interface MutationResponse {
  code: String!
  success: Boolean!
  message: String!
}

scalar UInt64
