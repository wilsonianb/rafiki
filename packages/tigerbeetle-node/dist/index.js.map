{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["const binding: Binding = require('./client.node')\ninterface Binding {\n  init: (args: BindingInitArgs) => Context\n  request: (context: Context, operation: Operation, batch: Event[], result: ResultCallback) => void\n  raw_request: (context: Context, operation: Operation, raw_batch: Buffer, result: ResultCallback) => void\n  tick: (context: Context) => void,\n  deinit: (context: Context) => void,\n  tick_ms: number\n}\n\ninterface BindingInitArgs {\n  cluster_id: number, // u32\n  replica_addresses: Buffer,\n}\n\nexport interface InitArgs {\n  cluster_id: number, // u32\n  replica_addresses: Array<string | number>,\n}\n\nexport type Context = object\n\nexport type Account = {\n  id: bigint // u128\n  user_data: bigint // u128\n  reserved: Buffer // [48]u8\n  unit: number // u16, unit of value\n  code: number // u16, A chart of accounts code describing the type of account (e.g. clearing, settlement)\n  flags: number // u32\n  debits_reserved: bigint // u64\n  debits_accepted: bigint // u64\n  credits_reserved: bigint // u64\n  credits_accepted: bigint // u64\n  timestamp: bigint // u64, Set this to 0n - the actual value will be set by TigerBeetle server\n}\n\nexport enum AccountFlags {\n  linked = (1 << 0),\n  debits_must_not_exceed_credits = (1 << 1),\n  credits_must_not_exceed_debits = (1 << 2)\n}\n\nexport enum CreateAccountError {\n  linked_event_failed = 1,\n  exists,\n  exists_with_different_user_data,\n  exists_with_different_reserved_field,\n  exists_with_different_unit,\n  exists_with_different_code,\n  exists_with_different_flags,\n  exceeds_credits,\n  exceeds_debits,\n  reserved_field,\n  reserved_flag_padding,\n}\n\nexport type CreateAccountsError = {\n  index: number,\n  code: CreateAccountError,\n}\n\nexport type Transfer = {\n  id: bigint, // u128\n  debit_account_id: bigint, // u128\n  credit_account_id: bigint, // u128\n  user_data: bigint, // u128\n  reserved: Buffer, // [32]u8\n  timeout: bigint, // u64, in nano-seconds\n  code: number, // u32 accounting system code to describe the type of transfer (e.g. settlement)\n  flags: number, // u32\n  amount: bigint, // u64,\n  timestamp: bigint, // u64, Set this to 0n - the actual value will be set by TigerBeetle server\n}\n\nexport enum TransferFlags {\n  linked = (1 << 0),\n  two_phase_commit = (1 << 1),\n  condition = (1 << 2) // whether or not a condition will be supplied\n}\n\nexport enum CreateTransferError {\n  linked_event_failed = 1,\n  exists,\n  exists_with_different_debit_account_id,\n  exists_with_different_credit_account_id,\n  exists_with_different_user_data,\n  exists_with_different_reserved_field,\n  exists_with_different_code,\n  exists_with_different_amount,\n  exists_with_different_timeout,\n  exists_with_different_flags,\n  exists_and_already_committed_and_accepted,\n  exists_and_already_committed_and_rejected,\n  reserved_field,\n  reserved_flag_padding,\n  debit_account_not_found,\n  credit_account_not_found,\n  accounts_are_the_same,\n  accounts_have_different_units,\n  amount_is_zero,\n  exceeds_credits,\n  exceeds_debits,\n  two_phase_commit_must_timeout,\n  timeout_reserved_for_two_phase_commit,\n}\n\nexport type CreateTransfersError = {\n  index: number,\n  code: CreateTransferError,\n}\n\nexport type Commit = {\n  id: bigint, // u128\n  reserved: Buffer, // [32]u8\n  code: number, // u32 accounting system code describing the reason for accept/reject\n  flags: number, // u32\n  timestamp: bigint, // u64, Set this to 0n - the actual value will be set by TigerBeetle server\n}\n\nexport enum CommitFlags {\n  linked = (1 << 0),\n  reject = (1 << 1),\n  preimage = (1 << 2) // whether or not a pre-image will be supplied\n}\n\nexport enum CommitTransferError {\n  linked_event_failed = 1,\n  reserved_field,\n  reserved_flag_padding,\n  transfer_not_found,\n  transfer_not_two_phase_commit,\n  transfer_expired,\n  already_committed,\n  already_committed_but_accepted,\n  already_committed_but_rejected,\n  debit_account_not_found,\n  credit_account_not_found,\n  debit_amount_was_not_reserved,\n  credit_amount_was_not_reserved,\n  exceeds_credits,\n  exceeds_debits,\n  condition_requires_preimage,\n  preimage_requires_condition,\n  preimage_invalid,\n}\n\nexport type CommitTransfersError = {\n  index: number,\n  code: CommitTransferError,\n}\n\nexport type AccountID = bigint // u128\nexport type TransferID = bigint // u128\n\nexport type Event = Account | Transfer | Commit | AccountID | TransferID\nexport type Result = CreateAccountsError | CreateTransfersError | CommitTransfersError | Account | Transfer\nexport type ResultCallback = (error: undefined | Error, results: Result[]) => void\n\nexport enum Operation {\n  CREATE_ACCOUNT = 3,\n  CREATE_TRANSFER,\n  COMMIT_TRANSFER,\n  ACCOUNT_LOOKUP,\n  TRANSFER_LOOKUP\n}\n\nexport interface Client {\n  createAccounts: (batch: Account[]) => Promise<CreateAccountsError[]>\n  createTransfers: (batch: Transfer[]) => Promise<CreateTransfersError[]>\n  commitTransfers: (batch: Commit[]) => Promise<CommitTransfersError[]>\n  lookupAccounts: (batch: AccountID[]) => Promise<Account[]>\n  lookupTransfers: (batch: TransferID[]) => Promise<Transfer[]>\n  request: (operation: Operation, batch: Event[], callback: ResultCallback) => void\n  rawRequest: (operation: Operation, rawBatch: Buffer, callback: ResultCallback) => void\n  destroy: () => void\n}\n\nlet _args: InitArgs | undefined = undefined\nconst isSameArgs = (args: InitArgs): boolean => {\n  if (typeof _args === 'undefined') {\n    return false\n  }\n\n  if (_args.replica_addresses.length !== args.replica_addresses.length) {\n    return false\n  }\n\n  let isSameReplicas = true\n  args.replica_addresses.forEach((entry, index) => {\n    if (_args?.replica_addresses[index] !== entry) {\n      isSameReplicas = false\n    }\n  })\n\n  return args.cluster_id === _args.cluster_id &&\n          isSameReplicas\n}\n\nlet _client: Client | undefined = undefined\nlet _interval: NodeJS.Timeout | undefined = undefined\n// here to wait until  `ping` is sent to server so that connection is registered - temporary till client table and sessions are implemented.\nlet _pinged = false\n// TODO: allow creation of clients if the arguments are different. Will require changes in node.zig as well.\nexport function createClient (args: InitArgs): Client {\n  const duplicateArgs = isSameArgs(args)\n  if (!duplicateArgs && typeof _client !== 'undefined'){\n    throw new Error('Client has already been initialized with different arguments.')\n  }\n\n  if (duplicateArgs && typeof _client !== 'undefined'){\n    throw new Error('Client has already been initialized with the same arguments.')\n  }\n\n  _args = Object.assign({}, { ...args })\n  const context = binding.init({\n    ...args,\n    replica_addresses: Buffer.from(args.replica_addresses.join(','))\n  })\n\n  const request = (operation: Operation, batch: Event[], callback: ResultCallback) => {\n    binding.request(context, operation, batch, callback)\n  }\n\n  const rawRequest = (operation: Operation, rawBatch: Buffer, callback: ResultCallback) => {\n    binding.raw_request(context, operation, rawBatch, callback)\n  }\n\n  const createAccounts = async (batch: Account[]): Promise<CreateAccountsError[]> => {\n    // here to wait until  `ping` is sent to server so that connection is registered - temporary till client table and sessions are implemented.\n    if (!_pinged) {\n      await new Promise<void>(resolve => {\n        setTimeout(() => {\n          _pinged = true\n          resolve()\n        }, 600)\n      })\n    }\n    return new Promise((resolve, reject) => {\n      const callback = (error: undefined | Error, results: CreateAccountsError[]) => {\n        if (error) {\n          reject(error)\n          return\n        }\n        resolve(results)\n      }\n\n      try {\n        binding.request(context, Operation.CREATE_ACCOUNT, batch, callback)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  const createTransfers = async (batch: Transfer[]): Promise<CreateTransfersError[]> => {\n    // here to wait until  `ping` is sent to server so that connection is registered - temporary till client table and sessions are implemented.\n    if (!_pinged) {\n      await new Promise<void>(resolve => {\n        setTimeout(() => {\n          _pinged = true\n          resolve()\n        }, 600)\n      })\n    }\n    return new Promise((resolve, reject) => {\n      const callback = (error: undefined | Error, results: CreateTransfersError[]) => {\n        if (error) {\n          reject(error)\n          return\n        }\n        resolve(results)\n      }\n\n      try {\n        binding.request(context, Operation.CREATE_TRANSFER, batch, callback)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  const commitTransfers = async (batch: Commit[]): Promise<CommitTransfersError[]> => {\n    // here to wait until  `ping` is sent to server so that connection is registered - temporary till client table and sessions are implemented.\n    if (!_pinged) {\n      await new Promise<void>(resolve => {\n        setTimeout(() => {\n          _pinged = true\n          resolve()\n        }, 600)\n      })\n    }\n    return new Promise((resolve, reject) => {\n      const callback = (error: undefined | Error, results: CommitTransfersError[]) => {\n        if (error) {\n          reject(error)\n          return\n        }\n        resolve(results)\n      }\n\n      try {\n        binding.request(context, Operation.COMMIT_TRANSFER, batch, callback)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  const lookupAccounts = async (batch: AccountID[]): Promise<Account[]> => {\n    return new Promise((resolve, reject) => {\n      const callback = (error: undefined | Error, results: Account[]) => {\n        if (error) {\n          reject(error)\n          return\n        }\n        resolve(results)\n      }\n\n      try {\n        binding.request(context, Operation.ACCOUNT_LOOKUP, batch, callback)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  const lookupTransfers = async (batch: TransferID[]): Promise<Transfer[]> => {\n    return new Promise((resolve, reject) => {\n      const callback = (error: undefined | Error, results: Transfer[]) => {\n        if (error) {\n          reject(error)\n          return\n        }\n        resolve(results)\n      }\n\n      try {\n        binding.request(context, Operation.TRANSFER_LOOKUP, batch, callback)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  const destroy = (): void => {\n    binding.deinit(context)\n    if (_interval){\n      clearInterval(_interval)\n    }\n    _client = undefined\n  }\n\n  _client = {\n    createAccounts,\n    createTransfers,\n    commitTransfers,\n    lookupAccounts,\n    lookupTransfers,\n    request,\n    rawRequest,\n    destroy\n  }\n\n  _interval = setInterval(() => {\n    binding.tick(context)\n  }, binding.tick_ms)\n\n  return _client\n}\n"]}